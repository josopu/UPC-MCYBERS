/* Compile with: gcc -o Unit2Libcap Unit2Libcap.c -lpcap */
/*
Implement a C program that uses libpcap to collect live traffic from a network interface in your computer.
The program has to collect only traffic with destination port 80 or 443.
For each collected packet, the program has to show in the screen 
    its timestamp (i.e., time when it was received)
    its source IP address
    its destination IP address 
    the length of the packet in the wire
The snaplen should be configured to the minimum value that allows you to get the required information.
You can test the program by running it while opening a web page in your browser.
The packets generated by the web browser should be printed in the screen.
You have to deliver the .c file only.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pcap.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <net/ethernet.h>


void packet_handler(unsigned char *user_data, const struct pcap_pkthdr *packet_header, const unsigned char *packet) {
    /* Pointers to start point of various headers */
    struct ip *ip_header;
    struct tcphdr *tcp_header;
    const struct ether_header* ethernetHeader;
    
    /* Header lengths in bytes */
    int ethernet_header_length = 14; /* Doesn't change */

    /* Find start of IP header */
    ip_header = (struct ip*)(packet + ethernet_header_length);

    tcp_header = (struct tcphdr*)(packet + sizeof(struct ether_header) + sizeof(struct ip));
    
    if (tcp_header->dest == 80 || tcp_header->dest == 443 || 1==1) { // If I delete "1==1" it will print nothing, port dest is never 80 nor 443
        fprintf(stdout, "Src IP: %s\n", inet_ntoa(ip_header->ip_src));
        fprintf(stdout, "Dst IP: %s\n", inet_ntoa(ip_header->ip_dst));
        fprintf(stdout, "Timestamp: %ld.%ld\n", packet_header->ts.tv_sec, packet_header->ts.tv_usec);
        fprintf(
            stdout, "Pkt Len: %d bytes  -- [Debug left on purpose] Dst Port: %d | Src Port: %d]\n\n",
            packet_header->len,
            tcp_header->dest,
            tcp_header->source
        );
    }
}


int main() {
    char iface[256];
    *iface = 0;  // Write your network interface if you don't want libpcap to find it (in a dummy way)
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle;
    pcap_if_t *ifaces = NULL;

    // If no network iface specified, get the first one
    if (!*iface) {
        if (pcap_findalldevs(&ifaces, errbuf)){
            fprintf(stderr, "pcap_findalldevs(): %s\n", errbuf);
            return -1;
        }
        strcpy(iface, ifaces[0].name);
    }
    fprintf(stdout, "Scanning interface: %s\n", iface);

    // Open the device for live capture
    handle = pcap_open_live(iface, BUFSIZ, 1, 1000, errbuf);
    if (handle == NULL) {
        fprintf(stderr, "pcap_open_live(): %s\n", errbuf);
        return -1;
    }
    
    // Convert the packet filter expression for HTTP and HTTPS filtering, into a packet filter binary
    struct bpf_program bpf;
    char filter_exp[] = "tcp dst port 80 or tcp dst port 443";
    bpf_u_int32 netmask;

    if (pcap_compile(handle, &bpf, filter_exp, 0, netmask) == PCAP_ERROR) {
        fprintf(stderr, "pcap_compile(): %s\n", pcap_geterr(handle));
        return -1;
    }

    // Bind the packet filter to the libpcap handle
    if (pcap_setfilter(handle, &bpf) == PCAP_ERROR) {
        fprintf(stderr, "pcap_setfilter(): %s\n", pcap_geterr(handle));
        return -1;
    }

    // Start capturing packets
    if (pcap_loop(handle, 0, packet_handler, NULL) < 0) {
        fprintf(stderr, "pcap_loop() failed: %s\n", pcap_geterr(handle));
        return -1;
    }

    // Close the handle
    pcap_close(handle);

    return 0;
}
